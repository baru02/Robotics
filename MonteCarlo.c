#include "sample.h"
//#pragma config(Sensor, S1, touchSensor, sensorTouch)
//#pragma config(Sensor, S2, sonarSensor, sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void exercise();
void exercise53();
void pidSetup();
void stop();
void initialiseArrays(float xinit, float yinit, float rotinit);
void rotate(float deg);
void move(int ncm);
void moveRotations(int rotations);
int round(float f);
int deg2rotations(int deg);
int cm2rotations(float ncm);
void drawParticles();
void updateArraysRotation( int deg );
void updateArraysStraight( int distance );
float atan2Degrees(float x, float y);
void navigateToWaypoint (float XDest, float YDest);
float calculate_likelihood(float x, float y, float theta, float z);

int findIndexOfResampledParticle (float randNum);
void initialiseWeights();
void updateWeightArray(float likelihood);
void updateCumulativeWeightArray();
void normalise();
void resample();

 //current position from the point (0,0) in engine rotations
int x = 0;
int y = 0;

//current rotation of the robot in degrees
float rotation = 0;

float rotationsForCm = 31.94; //number of rotations required for a cm
float rotationsFordeg = 3.64; //number of rotations required to turn for a degree

int power = 10;

const int NUMBER_OF_PARTICLES = 100;
const int NUMBER_OF_WALLS = 8;
const float DISPLAY_SCALE = 1.0; //number of centimeters per pixel point on the screen

float xArray[NUMBER_OF_PARTICLES];
float yArray[NUMBER_OF_PARTICLES];
float rotationArray[NUMBER_OF_PARTICLES];
float weightArray[NUMBER_OF_PARTICLES];
float cumulativeWeightArray[NUMBER_OF_PARTICLES];

int xOffset = 30;
int yOffset = 10;

// Definitions of walls
// a: O to A
// b: A to B
// c: C to D
// d: D to E
// e: E to F
// f: F to G
// g: G to H
// h: H to O
//                                      a    b    c    d    e    f    g    h
float wallAxArray[NUMBER_OF_WALLS] = {  0,   0,  84,  84, 168, 168, 210, 210};
float wallAyArray[NUMBER_OF_WALLS] = {  0, 168, 126, 210, 210,  84,  84,   0};
float wallBxArray[NUMBER_OF_WALLS] = {  0,  84,  84, 168, 168, 210, 210,   0};
float wallByArray[NUMBER_OF_WALLS] = {168, 168, 210, 210,  84,  84,   0,   0};


int round(float f)
{
  return (f>0)?(int)(f+0.5):(int)(f - 0.5);
}

task main() {
    pidSetup();

    initialiseArrays( x, y, rotation );
    rotate(-90);
    //exercise();
    //exercise53();

}

// Sets the weights to be equal (1/NUMBER_OF_PARTICLES) each in the beginning.
void initialiseWeights() {
  for (int i=0; i<NUMBER_OF_PARTICLES; ++i) {
    weightArray[i] = 1/NUMBER_OF_PARTICLES;  
  }
}

// Updates weights taking into account likelihood of each particle. 
void updateWeightArray(float likelihood) {
  for(int i=0; i<NUMBER_OF_PARTICLES; ++i) {
    weightArray[i] = likelihood*weightArray[i];
  }
}

// We assume that we have more than 1 particle.
void updateCumulativeWeightArray() {
  cumulativeWeightArray[0] = weightArray[0];
  for(int i=1; i<NUMBER_OF_PARTICLES; ++i) {
    cumulativeWeightArray[i] = cumulativeWeightArray[i-1] + weightArray[i];
  }
}

// Scales weights of all particles so that they all add up to 1.
void normalise () {
  // calculate sum of all unnormalised weights:
  int W = 0;
  for(int i=0; i<NUMBER_OF_PARTICLES; ++i) {
    W+=weightArray[i];
  }
  for(int i=0; i<NUMBER_OF_PARTICLES; ++i) {
    weightArray[i] = weightArray[i]/W;  
  }
}

void resample() {
  float tempXArray[NUMBER_OF_PARTICLES];
  float tempYArray[NUMBER_OF_PARTICLES];
  float tempThetaArray[NUMBER_OF_PARTICLES];
  int newParticleIndex = 0;
  float randNum;
  for(int i=0; i<NUMBER_OF_PARTICLES; ++i) {
    randNum = (float) (random(100))/100.0; 
    int indexOfResPart = findIndexOfResampledParticle(randNum);
    tempXArray[newParticleIndex] = xArray[indexOfResPart];
    tempYArray[newParticleIndex] = yArray[indexOfResPart];
    tempThetaArray[newParticleIndex] = rotationArray[indexOfResPart];
  }
  
  // update the arrays with old particles with the ones that were resampled.
  for(int i=0; i<NUMBER_OF_PARTICLES; ++i) {
    xArray[i] = tempXArray[i];
    yArray[i] = tempYArray[i];
    rotationArray[i] = tempThetaArray[i];
  }
  
}

// Iterates through the cumulativeWeightArray and returns 
// index of a particle that was resampled.
int findIndexOfResampledParticle (float randNum) {
  // the range of cumulative probabilities for the first particle
  // is 0 - probability of the first particle
  if(randNum >= 0 && cumulativeWeightArray[0]) return 0;
  for(int i=1; i<NUMBER_OF_PARTICLES; ++i) {
    if(randNum>= cumulativeWeightArray[i-1] && randNum<cumulativeWeightArray[i])
      return i;
  }
}

// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines
// intersect the intersection point may be stored in the floats i_x and i_y.
char get_line_intersection(float p0_x, float p0_y, float p1_x, float p1_y,
    float p2_x, float p2_y, float p3_x, float p3_y, float *i_x, float *i_y)
{
    float s1_x, s1_y, s2_x, s2_y;
    s1_x = p1_x - p0_x;     s1_y = p1_y - p0_y;
    s2_x = p3_x - p2_x;     s2_y = p3_y - p2_y;

    float s, t;
    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);

    if (s >= 0 && s <= 1 && t >= 0 && t <= 1)
    {
        // Collision detected
        if (i_x != NULL)
            *i_x = p0_x + (t * s1_x);
        if (i_y != NULL)
            *i_y = p0_y + (t * s1_y);
        return 1;
    }

    return 0; // No collision
}

float calculate_likelihood(float x, float y, float theta, float z){
  //find which wall was hit
	float xn = x + 2 * z * cos(theta);
	float yn = y + 2 * z * sin(theta);

	int wall = -1;
	float wallHitX = 0;
	float wallHitY = 0;

	for(int i = 0; i < NUMBER_OF_WALLS; i++){
		int pAx = wallAxArray[i];
		int pAy = wallAyArray[i];
		int pBx = wallBxArray[i];
		int pBy = wallByArray[i];

		float wallIX = 0;
		float wallIY = 0;

		char intersect = get_line_intersection(x, y, xn, yn, pAx, pAy, pBx, pBy, &wallIX, &wallIY);

		if( intersect ){
			//if we already found a wall choose the closer one
			if(wall > 0){
				//check which wall is closer
				float newD = sqrt(
					pow( abs(x-wallIX), 2 ) +
					pow( abs(y-wallIY), 2)
					);
				float oldD = sqrt(
					pow( abs(x-wallHitX), 2 ) +
					pow( abs(y-wallHitY), 2)
					);

				if(newD < oldD){
					wall = i;
					wallHitX = wallIx;
					wallHitY = wallIy;
				}
			} else {
				wall = i;
				wallHitX = wallIx;
				wallHitY = wallIy;
			}
		}
	}
	//compute m - expected distance

	float m = sqrt(
		pow( abs(x-wallHitX), 2 ) +
		pow( abs(y-wallHitY), 2)
		);

	//compare z and m and compute the likehood
	const float K = 1.0; //no particular reason why 1
	float sd = 0.1; //random as well
	float likehood = exp(-1*(z-m)*(z-m)/(2*sd)) + K;

	return likehood;
}


void initialiseArrays(float xinit, float yinit, float rotinit) {
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    xArray[i] = xinit;
    yArray[i] = yinit;
    rotationArray[i] = rotinit;
  }
}

void exercise() {
    int i;
    for (i = 0; i < 4; i++) {
        for(int j = 0; j < 2; j++){
          move( 20 );
          drawParticles();
        }

        rotate( 90 );
    }
}

void exercise53(){
  navigateToWaypoint( 0.5 , 0.5 );
  navigateToWaypoint( 0.5 , -0.2 );
  navigateToWaypoint( 0 , 0 );
}

void pidSetup() {
    nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
    nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
}

int cm2rotations(float ncm) {
    return round( ncm * rotationsForCm );
}

int deg2rotations(int deg) {
    return deg * rotationsFordeg;
}

void updatePosition(int rotations) {
    int oldX = x;
    int oldY = y;

    x += cosDegrees( rotation ) * abs( rotations );
    y += sinDegrees( rotation ) * abs( rotations );

    int opx =  round( oldX/( rotationsForCm * DISPLAY_SCALE ) ) + xOffset;
    int opy =  round( oldY/( rotationsForCm * DISPLAY_SCALE ) ) + yOffset;
    int px = round( x/( rotationsForCm * DISPLAY_SCALE ) ) + xOffset;
    int py = round( y/( rotationsForCm * DISPLAY_SCALE ) ) + yOffset;

    nxtDrawLine( opx, opy, px, py );
}

void stop() {
    motor[motorA] = 0;
    motor[motorC] = 0;
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;
}

void rotate(float deg) {
    if(deg > -1 && deg < 1) return;

    int rotations = deg2rotations( abs( deg ) );

    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;

    nMotorEncoderTarget[motorA] = rotations;
    nMotorEncoderTarget[motorC] = rotations;

    int sign = (deg < 0) ? -1 : 1;

    motor[motorA] = sign * -power;
    motor[motorC] = sign * power;

    while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
      //EndTimeSlice();
    }

    rotation += deg;
    stop();

    updateArraysRotation( deg );
}

void move(int ncm) {
    int rotations = cm2rotations( ncm );
    moveRotations( rotations );
}

void moveRotations( int rotations ){
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;

    int sign = (rotations < 0) ? -1 : 1;

    //set the number of rquired rotations and power of motors
    nMotorEncoderTarget[motorA] = rotations;
    motor[motorA] = sign * power;
    motor[motorC] = sign * power;

    while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
      //EndTimeSlice()
    }

    stop();

    //update our coordinates after the movement

    updatePosition( sign * rotations );
    updateArraysStraight( rotations );
  }

void drawParticles()
{
  // Draw the particle set
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    int px = round( xArray[i]/( rotationsForCm * DISPLAY_SCALE ) ) + xOffset;
    int py = round( yArray[i]/( rotationsForCm * DISPLAY_SCALE ) ) + yOffset;

    nxtSetPixel( px, py );
  }
}

void updateArraysStraight( int distance )
{
  //Update positions in array
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    float gaussianFloat1 = sampleGaussian( 0.0, 1.0 );
    float gaussianFloat2 = sampleGaussian( 0.0, 1.0 );
    xArray[i] += ( distance+gaussianFloat1 ) * cosDegrees( rotationArray[i] );
    yArray[i] += ( distance+gaussianFloat1 ) * sinDegrees( rotationArray[i] );
    rotationArray[i] += gaussianFloat2;
  }
}

void updateArraysRotation( int deg )
{
  //Update positions in the array
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    float gaussianFloat1 = sampleGaussian( 0.0, 1.0 );
    rotationArray[i] += ( deg + gaussianFloat1 );
  }
}


void navigateToWaypoint (float XDest, float YDest)
{
   float XStart = x;
   float YStart = y;
   float RStart = rotation;

   //Compute the estimated points
   for( int i = 0; i < NUMBER_OF_PARTICLES; i++){
    XStart += xArray[i];
    YStart += yArray[i];
    RStart += rotationArray[i];
   }

   XStart = XStart / ( NUMBER_OF_PARTICLES + 1 );
   YStart = YStart / ( NUMBER_OF_PARTICLES + 1 );

   //Assign estimated coordinates to our coordinates
   x = round( XStart );
   y = round( YStart );
   rotation = RStart = RStart / ( NUMBER_OF_PARTICLES + 1 );


   //Our point of destincation in the 'number of rotations' coordinate system
   float RXDest = XDest * rotationsForCm * 100;
   float RYDest = YDest * rotationsForCm * 100;

   //Distances on X and Y axis in rotations
   float XDiff = RXDest-XStart;
   float YDiff = RYDest-YStart;

   //Rotation we need to perform
	 float angleOfRotation = atan2Degrees( XDiff, YDiff ) - RStart;

	 //map rotation to the right quarter
	 while( angleOfRotation > 180 ) angleOfRotation -= 360;
	 while( angleOfRotation < -180 ) angleOfRotation += 360;

	 //distance in rotations
	 float m = sqrt( XDiff * XDiff + YDiff * YDiff );

	 //rotate and move the robot
   rotate( angleOfRotation );
   moveRotations( round( m ) );
}

float atan2Degrees(float x, float y)
{
  float angle = 0;

  if( x > 0) angle = radiansToDegrees( atan( y/x ) );
  else if( y >= 0 && x < 0 ) angle = radiansToDegrees( atan( y/x ) ) + 180;
  else if( y < 0 && x < 0 ) angle = radiansToDegrees( atan( y/x ) ) - 180;
  else if( y > 0 && x == 0 ) angle = 90;
  else if( y < 0 && x == 0 ) angle = -90;

  return angle;
}
