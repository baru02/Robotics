#pragma config(Sensor, S1,     sonarSensor,         sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "sample.h"

void exercise();
void exercise53();
void exercise6();
void pidSetup();
float getDistanceToWall(float a, float b, float theta, float x1, float y1, float x2, float y2);
void stop();
void initialiseArrays(float xinit, float yinit, float rotinit);
void rotate(float deg);
void move(int ncm);
void moveRotations(int rotations);
int round(float f);
int deg2rotations(int deg);
int cm2rotations(float ncm);
void drawParticles();
void updateArraysRotation( int deg );
void updateArraysStraight( int distance );
float atan2Degrees(float x, float y);
void navigateToWaypoint (float XDest, float YDest);
float checkIfLinesIntersect(float p0_x, float p0_y, float theta, float p2_x, float p2_y, float p3_x, float p3_y);
float calculate_likelihood(float x, float y, float theta, float z);
void initialiseWeights();
void updateWeightArray(float z);
void updateCumulativeWeightArray();
void normalise();
void resample();
int findIndexOfResampledParticle (float randNum);

 //current position from the point (0,0) in engine rotations
 int x = 0;
 int y = 0;

 //current rotation of the robot in degrees
 float rotation = 0;

  float rotationsForCm = 31.94; //number of rotations required for a cm
  float rotationsFordeg = 3.64; //number of rotations required to turn for a degree

  int power = 20;

  const int NUMBER_OF_PARTICLES = 100;
  const int NUMBER_OF_WALLS = 8;
  const int INFINITY = 10000000000.0;
	const float eps = 0.00000001;
	const float SENSOR_DEVIATION = 1.0;
	const float ALTERED_GAUSSIAN_CONSTANT = 0.01;
	const float BOX_DIMENSION = 230.0;
	const float SONAR_TO_CENTRE_CM = 6.3;

  float xArray[NUMBER_OF_PARTICLES];
  float yArray[NUMBER_OF_PARTICLES];
  float rotationArray[NUMBER_OF_PARTICLES];
  float weightArray[NUMBER_OF_PARTICLES];
  float cumulativeWeightArray[NUMBER_OF_PARTICLES];

  // Definitions of walls
  // a: O to A
  // b: A to B
  // c: C to D
  // d: D to E
  // e: E to F
  // f: F to G
  // g: G to H
  // h: H to O
  //                                      a    b    c    d    e    f    g    h
  float wallAxArray[NUMBER_OF_WALLS] = {  0,   0,  0.84,  0.84, 1.68, 1.68, 210, 2.10};
  float wallAyArray[NUMBER_OF_WALLS] = {  0, 1.68, 1.26, 2.10, 2.10, 0.84, 0.84,   0};
  float wallBxArray[NUMBER_OF_WALLS] = {  0,  0.84,  0.84, 1.68, 1.68, 2.10, 2.10,   0};
  float wallByArray[NUMBER_OF_WALLS] = {1.68, 1.68, 2.10, 2.10,  0.84,  0.84,   0,   0};

  int xOffset = 30;
  int yOffset = 10;

  const float DISPLAY_SCALE = 1.0; //number of centimeters per pixel point on the screen
  
   float max(float a, float b ){
   	  return (a>b)?a:b;
   }

   float min(float a, float b){
   	  return (a>b)?b:a;
   }

  int round(float f)
  {
  	  return (f>0)?(int)(f+0.5):(int)(f - 0.5);
  }

  bool floatEqual(float a, float b) {
	  return abs(a-b) < eps;
	}
	 
	float alteredGaussian(float x) {
	  return exp(-(x*x)/(2*(SENSOR_DEVIATION*SENSOR_DEVIATION))) + ALTERED_GAUSSIAN_CONSTANT;
	}
  // Takes the position estimate of a particle (x, y, theta) and the sonar measurement z
	// and returns a likelihood value.
	float calculate_likelihood(float x, float y, float theta, float z) {
	  // check which wall the particle would hit
	  float minDistance = INFINITY; // distance between the particle and the wall,
	  float wall = -1;
	  for(int i=0; i<NUMBER_OF_WALLS; ++i) {
	    float Ax = wallAxArray[i]*100*rotationsForCm;
	    float Ay = wallAyArray[i]*100*rotationsForCm;
	    float Bx = wallBxArray[i]*100*rotationsForCm;
	    float By = wallByArray[i]*100*rotationsForCm;
	 
	    float dis = getDistanceToWall(x,y,theta,Ax,Ay,Bx,By)
	    if( dis < minDistance){
	      minDistance = dis;
	      wall = i;
	    }
	    
	  }
	  if (floatEqual(minDistance,INFINITY)) {
	    return 1.; // FIXME: find better value
	  } else {
	    return alteredGaussian(minDistance - z);
	  }
	}
	 
	bool pointInInterval(float p, float x, float y) {
	  return p +eps > min(x,y) && p+eps < max(x,y);
	}
	 
	// Checks if direction of a particle in point (a, b) and angle 'theta' intersects with a wall
	// given by points l2_x1 and l2_y2. If lines don't intersect, returns -1, otherwise the expected distance
	// from the particle to the wall.
	float getDistanceToWall(float a, float b, float theta, float x1, float y1, float x2, float y2) {
	  // equation of direction line
	  float dA = sin(theta), dB = -cos(theta), dC= b*cos(theta)-a*sin(theta);
	  // equation of wall line
	  float wA = (y2-y1), wB = (x1-x2), wC = (y1-y2)*x1+y1*(x2-x1);
	  float determinant = wA*dB-wB*dA;
	  if (floatEqual(determinant, 0.0)) {
	    return INFINITY;
	  }
	  // calculating intercetion point
	  float Ix = (dC*wB-wC*dB)/determinant;
	  float Iy = (wC *dA - dC*wA)/determinant;
	  // check if right orientation of direction
	  if ( (Ix-a * cos(theta)) < eps) return INFINITY;
	  // check if on the wall segment
	  if (!(pointInInterval(Ix, x1, x2) && pointInInterval(Iy, y1,y2))) {
	    return INFINITY;
	  }
	  // FIXME: consider removing sqrt
	  return sqrt((Ix-a)*(Ix-a) + (Iy-b)*(Iy-b));
	 
	  // FIXME: test direction and segment tests
	  // FIXME: test angles > pi/2
	}

   task main() {
   	     pidSetup();
   	     initialiseWeights();
   	     //exercise();
         // exercise53();
         exercise6();
   }

   void initialiseArrays(float xinit, float yinit, float rotinit) {
   	  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
  	    xArray[i] = xinit;
        yArray[i] = yinit;
        rotationArray[i] = rotinit;
   	  }
   }

   void exercise() {
   	    int i;
        for (i = 0; i < 4; i++) {
	        for(int j = 0; j < 2; j++){
  	          move( 20 );
  	          drawParticles();
	        }

        	rotate( 90 );
        }
   }

   void exercise6(){
   	  //navigateToWaypoint( 0.2 , 0 );
 	    //navigateToWaypoint( 0.2 , 0.2 );
 	    x = 0.84 * rotationsForCm * 100;
 	    y = 0.3 * rotationsForCm * 100;
 	    initialiseArrays( x, y, rotation );
 	    navigateToWaypoint( 1.80 , 0.3 );
      //navigateToWaypoint( 1.80 , 0.54 );
      //navigateToWaypoint( 1.26 , 0.54 );
      //navigateToWaypoint( 1.26 , 1.68 );
      //navigateToWaypoint( 1.26 , 1.26 );
      //navigateToWaypoint( 0.3 , 0.54 );
      //navigateToWaypoint( 0.84 , 0.54 );
      //navigateToWaypoint( 0.84 , 0.3 );
   }


   void exercise53(){
   	  navigateToWaypoint( 0.5 , 0.5 );
 	    navigateToWaypoint( 0.5 , -0.2 );
 	    navigateToWaypoint( 0 , 0 );
   }

   void pidSetup() {
   	  nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
   	  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
   }

   int cm2rotations(float ncm) {
   	    return round( ncm * rotationsForCm );
   }

   int deg2rotations(int deg) {
   	    return deg * rotationsFordeg;
   }

   void updatePosition(int rotations) {
   	    int oldX = x;
        int oldY = y;

        x += cosDegrees( rotation ) * abs( rotations );
        y += sinDegrees( rotation ) * abs( rotations );

        int opx =  round( oldX/( rotationsForCm * DISPLAY_SCALE ) ) + xOffset;
        int opy =  round( oldY/( rotationsForCm * DISPLAY_SCALE ) ) + yOffset;
        int px = round( x/( rotationsForCm * DISPLAY_SCALE ) ) + xOffset;
        int py = round( y/( rotationsForCm * DISPLAY_SCALE ) ) + yOffset;

        nxtDrawLine( opx, opy, px, py );
   }

   void stop() {
   	    motor[motorA] = 0;
   	    motor[motorC] = 0;
   	    nMotorEncoder[motorA] = 0;
   	    nMotorEncoder[motorC] = 0;
   }

   void rotate(float deg) {
   	    if(deg > -1 && deg < 1) return;

   	    int rotations = deg2rotations( abs( deg ) );

   	    nMotorEncoder[motorA] = 0;
   	    nMotorEncoder[motorC] = 0;

   	    nMotorEncoderTarget[motorA] = rotations;
   	    nMotorEncoderTarget[motorC] = rotations;

   	    int sign = (deg < 0) ? -1 : 1;

   	    motor[motorA] = sign * power;
   	    motor[motorC] = sign * -power;

        while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
        	      //EndTimeSlice();
        }

	      rotation += deg;
	      stop();

   	    updateArraysRotation( deg );
   }

   void move(int ncm) {
   	    int rotations = cm2rotations( ncm );
   	    moveRotations( rotations );
   }

   void moveRotations( int rotations ){
   	    nMotorEncoder[motorA] = 0;
   	    nMotorEncoder[motorC] = 0;

   	    int sign = (rotations < 0) ? -1 : 1;

        //set the number of rquired rotations and power of motors
        nMotorEncoderTarget[motorA] = rotations;
        motor[motorA] = sign * power;
        motor[motorC] = sign * power;

        while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
        //EndTimeSlice()
        }

        stop();

        //update our coordinates after the movement

        updatePosition( sign * rotations );
        updateArraysStraight( rotations );
   }

   void drawParticles()
   {
   	  // Draw the particle set
   	    for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
   	    	    int px = round( xArray[i]/( rotationsForCm * DISPLAY_SCALE ) ) + xOffset;
   	    	    int py = round( yArray[i]/( rotationsForCm * DISPLAY_SCALE ) ) + yOffset;

   	    	    nxtSetPixel( px, py );
   	    }
   }

   void updateArraysStraight( int distance )
   {
   	  //Update positions in array
   	    for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
 	    	    float gaussianFloat1 = sampleGaussian( 0.0, 1.0 );
 	    	    float gaussianFloat2 = sampleGaussian( 0.0, 1.0 )/3;
 	    	    xArray[i] += ( distance+gaussianFloat1 ) * cosDegrees( rotationArray[i] );
 	    	    yArray[i] += ( distance+gaussianFloat1 ) * sinDegrees( rotationArray[i] );
 	    	    rotationArray[i] += gaussianFloat2;
   	    }
   }

   void updateArraysRotation( int deg )
   {
   	  //Update positions in the array
   	    for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
 	    	    float gaussianFloat1 = sampleGaussian( 0.0, 1.0 );
 	    	    rotationArray[i] += ( deg + gaussianFloat1 );
   	    }
   }


   void navigateToWaypoint (float XDest, float YDest)
   {
   	  float XStart = 0;
      float YStart = 0;
      float RStart = 0;

   	  //Compute the estimated points
      for( int i = 0; i < NUMBER_OF_PARTICLES; i++){
  	    XStart += (xArray[i]*weightArray[i]);
  	    YStart += (yArray[i]*weightArray[i]);
  	    RStart += (rotationArray[i]*weightArray[i]);
      }

      //Assign estimated coordinates to our coordinates
      x = round( XStart );
      y = round( YStart );
      rotation = RStart;

      //Our point of destincation in the 'number of rotations' coordinate system
      float RXDest = XDest * rotationsForCm * 100;
      float RYDest = YDest * rotationsForCm * 100;

      //Distances on X and Y axis in rotations
      float XDiff = RXDest-XStart;
      float YDiff = RYDest-YStart;

      //distance in rotations
   	 	float m = sqrt( XDiff * XDiff + YDiff * YDiff );

   	 	float is = m;

   	 	//move loop - moves 20cm until the distance from the ned-point is less than that
	 	 	while(is > 20){ //accuracy fix ;)
	 	 	  //compute our estimated position
	 	 	  //Compute the estimated points
	 	 	  XStart = 0;
	 	 	  YStart = 0;
	 	 	  RStart = 0;

	      for( int i = 0; i < NUMBER_OF_PARTICLES; i++){
	  	    XStart += (xArray[i]*weightArray[i]);
	  	    YStart += (yArray[i]*weightArray[i]);
	  	    RStart += (rotationArray[i]*weightArray[i]);
	      }

	      //Assign estimated coordinates to our coordinates
	      x = round( XStart );
	      y = round( YStart );
	      rotation = RStart;

	 	 	  XDiff = RXDest-XStart;
        YDiff = RYDest-YStart;

        //Rotation we need to perform
	      float angleOfRotation = atan2Degrees( XDiff, YDiff ) - RStart;

	  	  //map rotation to the right quarter
	  	 	while( angleOfRotation > 180 ) angleOfRotation -= 360;
	  	 	while( angleOfRotation < -180 ) angleOfRotation += 360;

        m = sqrt( XDiff * XDiff + YDiff * YDiff );

 		    //rotate and move the robot
 		    rotate( angleOfRotation );
 		    moveRotations( round( min((20 * rotationsForCm), m) ) );
 		    is -= min((20 * rotationsForCm), m);

 		    stop();
 		    float sonar = SensorValue(sonarSensor) - 6.3;
 		    updateWeightArray(sonar*rotationsForCm);
 		    normalise();
 		    updateCumulativeWeightArray();
 		    resample();
 		    drawParticles();
 		    wait1Msec(500);
	 	 	}
   }

   float atan2Degrees(float x, float y)
   {
   	  float angle = 0;

   	  if( x > 0) angle = radiansToDegrees( atan( y/x ) );
   	  else if( y >= 0 && x < 0 ) angle = radiansToDegrees( atan( y/x ) ) + 180;
   	  else if( y < 0 && x < 0 ) angle = radiansToDegrees( atan( y/x ) ) - 180;
   	  else if( y > 0 && x == 0 ) angle = 90;
   	  else if( y < 0 && x == 0 ) angle = -90;

   	  return angle;
   }

   // Sets the weights to be equal (1/NUMBER_OF_PARTICLES) each in the beginning.
   void initialiseWeights() {
   	  for (int i=0; i<NUMBER_OF_PARTICLES; ++i) {
   	  	    weightArray[i] = 1.0/(float)NUMBER_OF_PARTICLES;
   	  }
   }

   // Updates weights taking into account likelihood of each particle and given distance z measured by sonar.
   void updateWeightArray(float z) {
   	  float likelihood;
 	    for(int i=0; i<NUMBER_OF_PARTICLES; ++i) {
    	    likelihood = calculate_likelihood(xArray[i], yArray[i], rotationArray[i], z);
    	    weightArray[i] = likelihood*weightArray[i];
 	    }
   }

   // We assume that we have more than 1 particle.
   void updateCumulativeWeightArray() {
   	  cumulativeWeightArray[0] = weightArray[0];
 	    for(int i=1; i<NUMBER_OF_PARTICLES; ++i) {
 	      cumulativeWeightArray[i] = cumulativeWeightArray[i-1] + weightArray[i];
 	    }
   }

   // Scales weights of all particles so that they all add up to 1.
   void normalise() {
   	  // calculate sum of all unnormalised weights:
 	    float W = 0;
      for(int i=0; i<NUMBER_OF_PARTICLES; ++i) {
      	    W+=weightArray[i];
      }
      for(int i=0; i<NUMBER_OF_PARTICLES; ++i) {
        weightArray[i] = weightArray[i]/W;
      }
   }

   // Draws NUMBER_OF_PARTICLES particles given their weights and updates the arrays with the new particles.
   // Particles with bigger weights have higher probability to be drawn.
   void resample() {
   	  float tempXArray[NUMBER_OF_PARTICLES];
   	  float tempYArray[NUMBER_OF_PARTICLES];
      float temprotationArray[NUMBER_OF_PARTICLES];
      float randNum;
      for(int i=0; i<NUMBER_OF_PARTICLES; ++i) {
  	    randNum = (float) (random(100))/100.0;
        int indexOfResPart = findIndexOfResampledParticle(randNum);
	      tempXArray[i] = xArray[indexOfResPart];
        tempYArray[i] = yArray[indexOfResPart];
        temprotationArray[i] = rotationArray[indexOfResPart];
      }

      // update the arrays with old particles with the ones that were resampled.
      for(int i=0; i<NUMBER_OF_PARTICLES; ++i) {
  	    xArray[i] = tempXArray[i];
        yArray[i] = tempYArray[i];
        rotationArray[i] = temprotationArray[i];
      }
   }

   // Iterates through the cumulativeWeightArray and returns
   // index of a particle that was resampled.
   int findIndexOfResampledParticle (float randNum) {
   	  // the range of cumulative probabilities for the first particle
 	    // is 0 - probability of the first particle
      if(randNum >= 0 && randNum < cumulativeWeightArray[0]) return 0;
      for(int i=1; i<NUMBER_OF_PARTICLES; ++i) {
  	    if(randNum>= cumulativeWeightArray[i-1] && randNum<cumulativeWeightArray[i])
  	      return i;
      }
      return 0 ;
  }
