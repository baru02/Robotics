#include "sample.h"
//#pragma config(Sensor, S1, touchSensor, sensorTouch)
//#pragma config(Sensor, S2, sonarSensor, sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void exercise();
void pidSetup();
void stop();
void initialiseArrays(float xinit, float yinit, float rotinit);
void rotate(float deg);
void move(int ncm);
void moveRotations(int rotations);
int deg2rotations(int deg);
int cm2rotations(float ncm);
void drawParticles();
void updateArraysRotation( int deg );
void updateArraysStraight( int distance );
float atan2Degrees(float x, float y);
void navigateToWaypoint (float XDest, float YDest);

 //current position from the point (0,0) in engine rotations
int x = 0;
int y = 0;

//current rotation of the robot in degrees
float rotation = 0;

float rotationsForCm = 31.94; //number of rotations required for a cm
float rotationsFordeg = 3.64; //number of rotations required to turn for a degree

int power = 10;

const int NUMBER_OF_PARTICLES = 100;
float xArray[NUMBER_OF_PARTICLES];
float yArray[NUMBER_OF_PARTICLES];
float rotationArray[NUMBER_OF_PARTICLES];
const float DISPLAY_SCALE = 20.0;


int round(float f)
{
  return (f>0)?(int)(f+0.5):(int)(f - 0.5);
}

task sampling(){
  while(true){
    wait1Msec(2000);
    updateArraysStraight( round(40 * rotationsForCm) );
    drawParticles();
  }
}


task main() {
    pidSetup();
    
    initialiseArrays( x, y, rotation );
    
    exercise();
    
    //navigateToWaypoint( 0.2 , 0.2 );
    /*navigateToWaypoint( 0.2 , 0 );
    navigateToWaypoint( 0.3 , 0.1 );
    navigateToWaypoint( 0.4 , 0 );
    navigateToWaypoint( 0.3 , 0.1 );
    navigateToWaypoint( 0.2 , 0 );
    navigateToWaypoint( 0.1 , 0.1 );
    navigateToWaypoint( 0 , 0 );
    */
  }

void initialiseArrays(float xinit, float yinit, float rotinit) {
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    xArray[i] = xinit;
    yArray[i] = yinit;
    rotationArray[i] = rotinit;
  }
}

void exercise() {
    int i;
    for (i = 0; i < 4; i++) {
        StartTask(sampling);
        move(40);
        StopTask(sampling);
        rotate(90);
    }
}

void pidSetup() {
    nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
    nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
}

int cm2rotations(float ncm) {
    return round(ncm * rotationsForCm);
}

int deg2rotations(int deg) {
    return deg * rotationsFordeg;
}

void updatePosition(int rotations) {
    x += cosDegrees(rotation) * abs(rotations);
    y += sinDegrees(rotation) * abs(rotations);
}

void stop() {
    motor[motorA] = 0;
    motor[motorC] = 0;
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;
    wait1Msec(100);
}

void rotate(float deg) {
    if(deg > -1 && deg < 1) return;
    int rotations = deg2rotations(abs(deg));
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;

    nMotorEncoderTarget[motorA] = rotations;
    nMotorEncoderTarget[motorC] = rotations;

    int sign = (deg < 0) ? -1 : 1;

    motor[motorA] = sign * -power;
    motor[motorC] = sign * power;
    while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
      //EndTimeSlice();
    }

    rotation += deg;
    stop();

    updateArraysRotation( deg );
}

void move(int ncm) {
    int rotations = cm2rotations( ncm );
    moveRotations( rotations );
}

void moveRotations( int rotations ){
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;
    
    int sign = (rotations < 0) ? -1 : 1;
    
    //set the number of rquired rotations and power of motors
    nMotorEncoderTarget[motorA] = rotations;
    motor[motorA] = sign * power;
    motor[motorC] = sign * power;
    
    while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
      //EndTimeSlice();
    }
    
    stop();
    
    //update our coordinates after the movement
    updatePosition( sign * rotations );
    updateArraysStraight( rotations );
}

void drawParticles()
{
  // Draw the particle set
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    nxtSetPixel(round(xArray[i]/DISPLAY_SCALE),round(yArray[i]/DISPLAY_SCALE));
  }
}

void updateArraysStraight( int distance )
{
  //Update positions in array
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    float gaussianFloat1 = sampleGaussian(0.0, 1.0);
    float gaussianFloat2 = sampleGaussian(0.0, 1.0);
    xArray[i] += (distance+gaussianFloat1)*cosDegrees(rotationArray[i]);
    yArray[i] += (distance+gaussianFloat1)*sinDegrees(rotationArray[i]);
    rotationArray[i] += gaussianFloat2;
  }
}

void updateArraysRotation( int deg )
{
  //Update positions in array
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    float gaussianFloat1 = sampleGaussian(0.0, 1.0);
    rotationArray[i] += (deg + gaussianFloat1);
  }
}


void navigateToWaypoint (float XDest, float YDest)
{
   float XStart = x;
   float YStart = y;
   float RStart = rotation;
   
   //Compute the estimated points
   for( int i = 0; i < NUMBER_OF_PARTICLES; i++){
    XStart += xArray[i];
    YStart += yArray[i];
    RStart += rotationArray[i];
   }
   
   XStart = XStart / (NUMBER_OF_PARTICLES + 1);
   YStart = YStart / (NUMBER_OF_PARTICLES + 1);
   
   //Assign estimated coordinates to our coordinates
   x = round( XStart );
   y = round( YStart );
   rotation = RStart = RStart / (NUMBER_OF_PARTICLES + 1);
      
   
   //Our point of destincation in the 'number of rotations' coordinate system
   float RXDest = XDest * rotationsForCm * 100; 
   float RYDest = YDest * rotationsForCm * 100;
   
   //Distances on X and Y axis in rotations
   float XDiff = RXDest-XStart;
   float YDiff = RYDest-YStart;
   
   //Rotation we need to perform
   float angleOfRotation = atan2Degrees( XDiff, YDiff ) - RStart;
	  
	 //map rotation to the right quarter
	 while( angleOfRotation > 180 ) angleOfRotation -= 360;
	 while( angleOfRotation < -180 ) angleOfRotation += 360;
	   
	 //distance in rotations
	 float m = sqrt(XDiff * XDiff + YDiff * YDiff);
	 
	 //rotate and move the robot
   rotate( angleOfRotation );
   moveRotations( round(m) );
}

float atan2Degrees(float x, float y)
{
  float angle = 0;
  
  if( x > 0) angle = radiansToDegrees(atan(y/x));
  else if( y >= 0 && x < 0 ) angle = radiansToDegrees(atan(y/x)) + 180; 
  else if( y < 0 && x < 0 ) angle = radiansToDegrees(atan(y/x)) - 180; 
  else if( y > 0 && x == 0 ) angle = 90;
  else if( y < 0 && x == 0 ) angle = -90;
  
  return angle;
}
