#include "sample.h"
//#pragma config(Sensor, S1, touchSensor, sensorTouch)
//#pragma config(Sensor, S2, sonarSensor, sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void exercise();
void exercise53();
void pidSetup();
void stop();
void initialiseArrays(float xinit, float yinit, float rotinit);
void rotate(float deg);
void move(int ncm);
void moveRotations(int rotations);
int round(float f);
int deg2rotations(int deg);
int cm2rotations(float ncm);
void drawParticles();
void updateArraysRotation( int deg );
void updateArraysStraight( int distance );
float atan2Degrees(float x, float y);
void navigateToWaypoint (float XDest, float YDest);

 //current position from the point (0,0) in engine rotations
int x = 0;
int y = 0;

//current rotation of the robot in degrees
float rotation = 0;
 
float rotationsForCm = 31.94; //number of rotations required for a cm
float rotationsFordeg = 3.64; //number of rotations required to turn for a degree

int power = 10;

const int NUMBER_OF_PARTICLES = 100;
float xArray[NUMBER_OF_PARTICLES];
float yArray[NUMBER_OF_PARTICLES];
float rotationArray[NUMBER_OF_PARTICLES];

int xOffset = 30;
int yOffset = 10;

const float DISPLAY_SCALE = 1.0; //number of centimeters per pixel point on the screen


int round(float f)
{
  return (f>0)?(int)(f+0.5):(int)(f - 0.5);
}

task main() {
    pidSetup();
    
    initialiseArrays( x, y, rotation );
    
    //exercise();
    exercise53();
    
  }

void initialiseArrays(float xinit, float yinit, float rotinit) {
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    xArray[i] = xinit;
    yArray[i] = yinit;
    rotationArray[i] = rotinit;
  }
}

void exercise() {
    int i;
    for (i = 0; i < 4; i++) {
        for(int j = 0; j < 2; j++){
          move( 20 );
          drawParticles();
        }
        
        rotate( 90 );
    }
}

void exercise53(){
  navigateToWaypoint( 0.5 , 0.5 );
  navigateToWaypoint( 0.5 , -0.2 );
  navigateToWaypoint( 0 , 0 );
}

void pidSetup() {
    nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
    nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
}

int cm2rotations(float ncm) {
    return round( ncm * rotationsForCm );
}

int deg2rotations(int deg) {
    return deg * rotationsFordeg;
}

void updatePosition(int rotations) {
    int oldX = x;
    int oldY = y;
        
    x += cosDegrees( rotation ) * abs( rotations );
    y += sinDegrees( rotation ) * abs( rotations );

    int opx =  round( oldX/( rotationsForCm * DISPLAY_SCALE ) ) + xOffset;
    int opy =  round( oldY/( rotationsForCm * DISPLAY_SCALE ) ) + yOffset;
    int px = round( x/( rotationsForCm * DISPLAY_SCALE ) ) + xOffset;
    int py = round( y/( rotationsForCm * DISPLAY_SCALE ) ) + yOffset;
    
    nxtDrawLine( opx, opy, px, py );
}

void stop() {
    motor[motorA] = 0;
    motor[motorC] = 0;
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;
}

void rotate(float deg) {
    if(deg > -1 && deg < 1) return;
    
    int rotations = deg2rotations( abs( deg ) );
    
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;

    nMotorEncoderTarget[motorA] = rotations;
    nMotorEncoderTarget[motorC] = rotations;

    int sign = (deg < 0) ? -1 : 1;

    motor[motorA] = sign * -power;
    motor[motorC] = sign * power;
    
    while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
      //EndTimeSlice();
    }

    rotation += deg;
    stop();

    updateArraysRotation( deg );
}

void move(int ncm) {
    int rotations = cm2rotations( ncm );
    moveRotations( rotations );
}

void moveRotations( int rotations ){
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;
    
    int sign = (rotations < 0) ? -1 : 1;
    
    //set the number of rquired rotations and power of motors
    nMotorEncoderTarget[motorA] = rotations;
    motor[motorA] = sign * power;
    motor[motorC] = sign * power;
    
    while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
      //EndTimeSlice()
    }
    
    stop();
    
    //update our coordinates after the movement
    
    updatePosition( sign * rotations );
    updateArraysStraight( rotations );
  }

void drawParticles()
{
  // Draw the particle set
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    int px = round( xArray[i]/( rotationsForCm * DISPLAY_SCALE ) ) + xOffset;
    int py = round( yArray[i]/( rotationsForCm * DISPLAY_SCALE ) ) + yOffset;
    
    nxtSetPixel( px, py );
  }
}

void updateArraysStraight( int distance )
{
  //Update positions in array
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    float gaussianFloat1 = sampleGaussian( 0.0, 1.0 );
    float gaussianFloat2 = sampleGaussian( 0.0, 1.0 );
    xArray[i] += ( distance+gaussianFloat1 ) * cosDegrees( rotationArray[i] );
    yArray[i] += ( distance+gaussianFloat1 ) * sinDegrees( rotationArray[i] );
    rotationArray[i] += gaussianFloat2;
  }
}

void updateArraysRotation( int deg )
{
  //Update positions in the array
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
    float gaussianFloat1 = sampleGaussian( 0.0, 1.0 );
    rotationArray[i] += ( deg + gaussianFloat1 );
  }
}


void navigateToWaypoint (float XDest, float YDest)
{
   float XStart = x;
   float YStart = y;
   float RStart = rotation;
   
   //Compute the estimated points
   for( int i = 0; i < NUMBER_OF_PARTICLES; i++){
    XStart += xArray[i];
    YStart += yArray[i];
    RStart += rotationArray[i];
   }
   
   XStart = XStart / ( NUMBER_OF_PARTICLES + 1 );
   YStart = YStart / ( NUMBER_OF_PARTICLES + 1 );
   
   //Assign estimated coordinates to our coordinates
   x = round( XStart );
   y = round( YStart );
   rotation = RStart = RStart / ( NUMBER_OF_PARTICLES + 1 );
      
   
   //Our point of destincation in the 'number of rotations' coordinate system
   float RXDest = XDest * rotationsForCm * 100; 
   float RYDest = YDest * rotationsForCm * 100;
   
   //Distances on X and Y axis in rotations
   float XDiff = RXDest-XStart;
   float YDiff = RYDest-YStart;
   
   //Rotation we need to perform
	 float angleOfRotation = atan2Degrees( XDiff, YDiff ) - RStart;
	  
	 //map rotation to the right quarter
	 while( angleOfRotation > 180 ) angleOfRotation -= 360;
	 while( angleOfRotation < -180 ) angleOfRotation += 360;
	   
	 //distance in rotations
	 float m = sqrt( XDiff * XDiff + YDiff * YDiff );
	 
	 //rotate and move the robot
   rotate( angleOfRotation );
   moveRotations( round( m ) );
}

float atan2Degrees(float x, float y)
{
  float angle = 0;
  
  if( x > 0) angle = radiansToDegrees( atan( y/x ) );
  else if( y >= 0 && x < 0 ) angle = radiansToDegrees( atan( y/x ) ) + 180; 
  else if( y < 0 && x < 0 ) angle = radiansToDegrees( atan( y/x ) ) - 180; 
  else if( y > 0 && x == 0 ) angle = 90;
  else if( y < 0 && x == 0 ) angle = -90;
  
  return angle;
}
