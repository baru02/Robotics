#pragma config(Sensor, S1,     rightLightSensor,    sensorCOLORGREEN)
#pragma config(Sensor, S2,     rightTouchSensor,    sensorTouch)
#pragma config(Sensor, S3,     leftTouchSensor,     sensorTouch)
#pragma config(Sensor, S4,     leftLightSensor,     sensorCOLORGREEN)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void pidSetup();
void moveToTarget();
void rotate(int deg);
void stop();
void move(int ncm);
int cm2rotations(int ncm);
int deg2rotations(int deg);
void findLightSource();

int power = 15;
float rotationsForCm = 28.14; //number of rotations required for a cm
float rotationsFordeg = 3.48; //number of rotations required to turn for a degree

const tSensors rightLightSensor = (tSensors) S1;
const tSensors rightTouchSensor = (tSensors) S2;
const tSensors leftTouchSensor = (tSensors) S3;
const tSensors leftLightSensor = (tSensors) S4;

bool lightFound = false;
bool handleObstacleLeft = false;
bool handleObstacleRight = false;
bool passingByObstacle = false;

task checkLightSource(){
        while(true){
                  lightFound = ((SensorValue(rightLightSensor) > 18 || 
                                       SensorValue(rightLightSensor) > 18) && 
                                                            abs(SensorValue(rightLightSensor) - 
                                                                                     SensorValue(leftLightSensor)) < 10);
                                                                                           EndTimeSlice();
        }
}

void findLightSource(){
        if((SensorValue(rightLightSensor) > 18 || 
                SensorValue(rightLightSensor) > 18) &&
                        SensorValue(rightLightSensor) > SensorValue(leftLightSensor)){
                                  motor[motorA] = -power;
                                        motor[motorC] = power;
                        } else if((SensorValue(rightLightSensor) > 18 || 
                                SensorValue(rightLightSensor) > 18) &&
                                        SensorValue(rightLightSensor) < SensorValue(leftLightSensor)) {
                                                  motor[motorA] = power;
                                                        motor[motorC] = -power;
                                        } else {
                                                  motor[motorA] = power;
                                                        motor[motorC] = -power;
                                        }
}

task checkObstacles(){
        while(true){
                  wait1Msec(20);
                        handleObstacleLeft = SensorValue(leftTouchSensor) == 1;
                              handleObstacleRight = SensorValue(rightTouchSensor) == 1;
        }
}

int obstacleStep = 0;
void obstacleHandler(int step){  
          int direction = (handleObstacleLeft == true) ? -1 : 1; 
          
          if(step <=5) move(5);
          else if(step <=6) rotate(direction*90);
          else if (step<=11) move(5);
          else if (step<=12) rotate(-direction*90);
          else if (step<=17) move(-5);
                            
                              
}


task main() {
        pidSetup();
            StartTask(checkLightSource);
                StartTask(checkObstacles);
                    wait1Msec(500);
                        while(true){
                                        if(handleObstacleLeft || handleObstacleRight){
                                                   obstacleStep = 17;
                                                   passingByObstacle = true;
                                        } else if(obstacleStep > 0) {
                                           obstacleHandler(obstacleStep);
                                           obstacleStep--;
                                           if(obstacleStep ==0) passingByObstacle = false;
                                        } else if(!lightFound){ 
                                                    findLightSource();
                                        }  else if(!passingByObstacle){
                                                    moveToTarget();
                                        } else {
                                                    wait1Msec(400);
                                        }
                                        EndTimeSlice();
                        }
}

void moveToTarget(){
      motor[motorA] = power;
        motor[motorC] = power;
      
        wait1Msec(10);
        
     
}

void pidSetup() {
        nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
            nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
}

void rotate(int deg) {
        int rotations = deg2rotations(abs(deg));
            nMotorEncoder[motorA] = 0;
                nMotorEncoder[motorC] = 0;
                
                    nMotorEncoderTarget[motorA] = rotations;
                        nMotorEncoderTarget[motorC] = rotations;
                        
                            int sign = (deg < 0) ? -1 : 1;
                            
                                motor[motorA] = sign * -power;
                                    motor[motorC] = sign * power;
                                        while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
                                                  EndTimeSlice();
                                        }
                                            
                                                stop();
}

void move(int ncm) {
        int rotations = cm2rotations(abs(ncm));
            nMotorEncoder[motorA] = 0;
                nMotorEncoder[motorC] = 0;
                
                    int sign = (ncm < 0) ? -1 : 1;
                    
                        nMotorEncoderTarget[motorA] = rotations;
                            motor[motorA] = sign * power;
                                motor[motorC] = sign * power;
                                
                                    while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
                                              EndTimeSlice();
                                    }
                                        stop();
}

int cm2rotations(int ncm) {
        return ncm * rotationsForCm;
}

int deg2rotations(int deg) {
        return deg * rotationsFordeg;
}

void stop() {
        motor[motorA] = 0;
            motor[motorC] = 0;
                nMotorEncoder[motorA] = 0;
                    nMotorEncoder[motorC] = 0;
}
