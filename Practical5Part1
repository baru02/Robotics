#include "sample.h"
//#pragma config(Sensor, S1, touchSensor, sensorTouch)
//#pragma config(Sensor, S2, sonarSensor, sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void exercise();
void pidSetup();
void stop();
void initialiseArrays(float xinit, float yinit, float rotinit);
void rotate(float deg);
void move(int ncm);
int deg2rotations(int deg);
int cm2rotations(int ncm);
void drawParticles();
void updateArraysStraight();

int x = 0;
int y = 0;
float rotation = 0;

float rotationsForCm = 28.14; //number of rotations required for a cm
float rotationsFordeg = 3.48; //number of rotations required to turn for a degree

int power = 10;

const int NUMBER_OF_PARTICLES = 100;
float xArray[NUMBER_OF_PARTICLES];
float yArray[NUMBER_OF_PARTICLES];
float rotationArray[NUMBER_OF_PARTICLES];
const float DISPLAY_SCALE = 20.0;

task sampling(){
  while(true){
    wait1Msec(2000);
    updateArraysStraight();
    drawParticles();
  }
}


task main() {
    pidSetup();
    x+=400;
    y+=100;
    initialiseArrays(x,y,rotation);

    exercise();
}

void initialiseArrays(float xinit, float yinit, float rotinit) {
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
  	xArray[i] = xinit;
  	yArray[i] = yinit;
  	rotationArray = rotinit;
  }
}

void exercise() {
    int i;
    for (i = 0; i < 4; i++) {
        StartTask(sampling);
  	    move(40);
  	    StopTask(sampling);
  	    updateArraysStraight();
        rotate(90);
    }
}

void pidSetup() {
    nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
    nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
}

int cm2rotations(int ncm) {
    return ncm * rotationsForCm;
}

int deg2rotations(int deg) {
    return deg * rotationsFordeg;
}

void updatePosition(int rotations) {
    x += cosDegrees(rotation) * abs(rotations);
    y += sinDegrees(rotation) * abs(rotations);
    nxtSetPixel(x / DISPLAY_SCALE, y / DISPLAY_SCALE);
}

void stop() {
    motor[motorA] = 0;
    motor[motorC] = 0;
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;
    wait1Msec(100);
}

void rotate(float deg) {
    int rotations = deg2rotations(abs(deg));
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;

    nMotorEncoderTarget[motorA] = rotations;
    nMotorEncoderTarget[motorC] = rotations;

    int sign = (deg < 0) ? -1 : 1;

    motor[motorA] = sign * -power;
    motor[motorC] = sign * power;
    while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
      EndTimeSlice();
    }

    rotation += deg;
    stop();

  // update rotation error array
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
  float gaussianFloat1 = sampleGaussian(0.0, 1.0)*3;
  rotationArray[i] += deg + gaussianFloat1;
  }
}

void move(int ncm) {
    int rotations = cm2rotations(abs(ncm));
    nMotorEncoder[motorA] = 0;
    nMotorEncoder[motorC] = 0;

    int sign = (ncm < 0) ? -1 : 1;

    nMotorEncoderTarget[motorA] = rotations;
    motor[motorA] = sign * power;
    motor[motorC] = sign * power;

    int prevRotations = 0;
    int curRotations = 0;
    while (nMotorRunState[motorA] != runStateIdle && nMotorRunState[motorA] != runStateHoldPosition) {
        curRotations = abs(nMotorEncoder[motorA]);
        updatePosition(curRotations - prevRotations);
        prevRotations = curRotations;
        EndTimeSlice();
    }

    stop();
}

void drawParticles()
{
  // Draw the particle set
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
  	nxtSetPixel((int)(xArray[i]/DISPLAY_SCALE),(int)(yArray[i]/DISPLAY_SCALE));
  }

}

void updateArraysStraight()
{
  //Update positions in array
  for (int i = 0; i < NUMBER_OF_PARTICLES; i++) {
  	float gaussianFloat1 = sampleGaussian(0.0, 1.0)*3;
  	float gaussianFloat2 = sampleGaussian(0.0, 1.0)*3;
  	xArray[i] += (abs(x-xArray[i])+gaussianFloat1)*cosDegrees(rotationArray[i]);
  	yArray[i] += (abs(y-yArray[i])+gaussianFloat1)*sinDegrees(rotationArray[i]);
  	rotationArray[i] += gaussianFloat2;
  }
}
